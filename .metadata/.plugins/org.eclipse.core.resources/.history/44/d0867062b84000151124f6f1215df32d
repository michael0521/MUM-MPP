package innerclass;

import java.util.Comparator;
import java.util.List;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import quizclasses.Employee;
import quizclasses.EmployeeTestData;
import quizclasses.Pair;
import quizclasses.TraderTransactTestData;
import quizclasses.Transaction;

/**
 * SOLVE THE PROBLEMS HERE BY REPLACING LAMBDA EXPRESSIONS IN YOUR PIPELINE
 * SOLUTIONS WITH LOCAL INNER CLASSES
 *
 */
public class Main {
	public static void main(String[] args) {

		// SAMPLE: Use local inner classes to replace lambdas in your pipeline
		// solution to
		// this sample problem:
		// Print all Employee records for which name has length > 5 and birth
		// year is > 1970

		class NameLength implements Predicate<Employee> {
			public boolean test(Employee e) {
				return e.getName().length() > 5;
			}
		}
		class BirthYear implements Predicate<Employee> {
			public boolean test(Employee e) {
				return e.getYearOfBirth() > 1970;
			}
		}
		System.out.println("Sample Query");
		List<Employee> sampleData = EmployeeTestData.getList();

		List<Employee> result = sampleData.stream().filter(new NameLength()).filter(new BirthYear())
				.collect(Collectors.toList());
		// System.out.println(result);

		prob1();
		//prob2();
		//prob3();
	}

	// Transform your pipeline solution to prob1 in the pipeline package so that
	// every lambda is replaced by an instance of a
	// local inner class of the correct type
	public static void prob1() {


		class SalaryRange implements Predicate<Employee> {
			public boolean test(Employee e) {
				return e.getSalary() > 55000 && e.getSalary() < 120000;
			}
		}
		
		class PairsMapper implements Function<Employee, Pair>{
			@Override
			public Pair apply(Employee e) {
				return new Pair(e.getName(), e.getSalary());
			}
		}

		class MyComparator implements Comparator<Pair> {

			@Override
			public int compare(Pair o1, Pair o2) {
				int temp = o1.name.compareTo(o2.name);
				return temp == 0 ? -1 * (int)(o1.salary-o2.salary) : temp;
			}

		}
		
		class NameFunction implements Function<Pair, String>{
			@Override
			public String apply(Pair p) {
				return p.name;
			}
		}
		
		class SalaryFunction implements Function<Pair, Double>{

			@Override
			public Double apply(Pair p) {
				return -p.salary;
			}
			
		}
		// use this list
		List<Employee> list = EmployeeTestData.getList();
		//list.stream().filter(new SalaryRange()).map(new PairsMapper()).sorted(new MyComparator()).collect(Collectors.toList());
		List<Pair> pairs = list.stream().filter(new SalaryRange()).map(new PairsMapper()).sorted(Comparator.comparing(new NameFunction()).thenComparing(new SalaryFunction())).collect(Collectors.toList());
		System.out.println(pairs);
	}

	/// Transform your pipeline solution to prob2 so that
	// every lambda is replaced by an instance of a
	// local inner class of the correct type
	public static void prob2() {
		class ByYear implements Predicate<Transaction> {
			public boolean test(Transaction t) {
				return t.getYear() == 2011;
			}
		}

		class MyComparator implements Comparator<Transaction> {

			@Override
			public int compare(Transaction o1, Transaction o2) {
				return o1.getValue() - o2.getValue();
			}

		}
		// use this list
		List<Transaction> list = TraderTransactTestData.getTransactions();
		list.stream().filter(new ByYear()).sorted(new MyComparator()).forEach(e -> System.out.println(e));

	}

	// Transform your pipeline solution to prob3 so that
	// every lambda is replaced by an instance of a
	// local inner class of the correct type
	public static void prob3() {
		class ByCity implements Predicate<Transaction> {

			@Override
			public boolean test(Transaction t) {
				return t.getTrader().getCity() == "Cambridge";
			}

		}

		class MyComparator implements Comparator<Transaction> {

			@Override
			public int compare(Transaction o1, Transaction o2) {
				return o1.getTrader().getName().compareTo(o2.getTrader().getName());
			}

		}
		// Use this list
		List<Transaction> list = TraderTransactTestData.getTransactions();
		list.stream().filter(new ByCity()).distinct().sorted(new MyComparator()).forEach(e -> System.out.println(e));
		
	}
}
