package review.point2.quiz.lambdlib;

import java.util.Comparator;
import java.util.List;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

import quizclasses.Employee;
import quizclasses.Pair;
import quizclasses.Trader;
import quizclasses.Transaction;

public class LambdaLibrary {
	public final static String IMPLEMENT = "implement!";

	// sample query
	public final static TriFunction<List<Employee>, Integer, Integer, List<Employee>> SAMPLE = (list, namelength,
			year) -> list.stream().filter(e -> e.getName().length() > namelength).filter(e -> e.getYearOfBirth() > year)
					.collect(Collectors.toList());

	public final static TriFunction<List<Employee>, Integer, Integer, List<Pair>> PROB1 = (list, lowerSalary,
			upperSalary) -> list.stream().filter(e -> e.getSalary() > lowerSalary && e.getSalary() < upperSalary)
					// .sorted(Comparator.comparing(Employee::getName).thenComparing(Employee::getSalary,
					// (s1, s2) -> -1 * (s1 - s2)))
					.map(e -> new Pair(e.getName(), e.getSalary()))
					.sorted(Comparator.comparing((Pair p) -> p.name).thenComparing((Pair p) -> -p.salary))
					.collect(Collectors.toList());

	public final static BiFunction<List<Transaction>, Integer, List<Transaction>> PROB2 = (list, year) -> list.stream()
			.filter(t -> t.getYear() == year).sorted(Comparator.comparing(Transaction::getValue))
			.collect(Collectors.toList());

	public final static BiFunction<List<Transaction>, String, List<Trader>> PROB3 = (list, city) -> list.stream()
			.map(tran -> tran.getTrader()).filter(trader -> trader.getCity().equals(city))
			.sorted(
					// Comparator.comparing(Transaction::getTrader, (t1, t2) ->
					// t1.getName().compareTo(t2.getName())))
					Comparator.comparing(trader -> trader.getName()))
			.collect(Collectors.toList());
}
